Short answer: you can’t. By design, you cannot retrieve an Entra ID client secret from Microsoft using only tenant + client ID (there’s no API to “read back” a secret). A secret must be created by a tenant admin (or someone with the right role) and handed to you—or you use a secretless auth option.

Here are your workable paths, with copy-paste Java snippets:

⸻

Option A — Avoid secrets entirely (best)

A1) Managed Identity (when running on Azure)

No secret, no certificate. Azure issues tokens to your resource.

When to use: App Service, Functions, VM, Container Apps, AKS.

Java (azure-identity):

import com.azure.identity.ManagedIdentityCredentialBuilder;
import com.azure.core.credential.TokenRequestContext;

var cred = new ManagedIdentityCredentialBuilder()
    .clientId("<user-assigned-mi-id-optional>") // omit for system-assigned
    .build();

var token = cred.getToken(new TokenRequestContext()
    .addScopes("https://graph.microsoft.com/.default"))
    .block();
String bearer = "Bearer " + token.getToken();

Grant your Managed Identity the right roles/Graph app perms (admin consent still required).
You’ll also need Microsoft Graph application permissions consented by an admin for app-only calls.

⸻

A2) User-delegated (no secret) via Device Code Flow (local dev)

Interactive user login; good for development or flows where delegated permissions are OK.

When to use: You don’t have admin rights to create a secret, and your scenario can work with delegated scopes (e.g., user’s own OneDrive/SharePoint access).

Note: Copilot Retrieval API and many org-wide actions generally need application perms, so this is mainly for testing uploads or delegated Graph endpoints.

Java (MSAL4J device code):

import com.microsoft.aad.msal4j.*;

IClientApplication app = PublicClientApplication.builder("<CLIENT_ID>")
    .authority("https://login.microsoftonline.com/<TENANT_ID>")
    .build();

DeviceCodeFlowParameters params = DeviceCodeFlowParameters
    .builder(
        java.util.Set.of("Files.ReadWrite", "Sites.Read.All", "offline_access"))
    .deviceCodeConsumer(dc -> {
        System.out.println(dc.message()); // shows code & URL to sign in
    })
    .build();

IAuthenticationResult result = app.acquireToken(params).get();
String bearer = "Bearer " + result.accessToken();

Then call Graph with Authorization: bearer.

⸻

Option B — Use a certificate instead of a secret (no secrets in code)

If you can’t store a secret, a client certificate is often approved by security teams.

What admin must do: Upload your cert’s public key to the App Registration and grant Graph application permissions.
What you do: Keep the private key (PFX or PEM) and use it from Java.

Java (azure-identity, certificate):

import com.azure.identity.ClientCertificateCredential;
import com.azure.identity.ClientCertificateCredentialBuilder;
import com.azure.core.credential.TokenRequestContext;

ClientCertificateCredential cred = new ClientCertificateCredentialBuilder()
    .tenantId("<TENANT_ID>")
    .clientId("<CLIENT_ID>")
    .pfxCertificate("<path>/app-auth.pfx", "<pfxPassword>") // or .pemCertificate()
    .build();

var token = cred.getToken(new TokenRequestContext()
    .addScopes("https://graph.microsoft.com/.default"))
    .block();
String bearer = "Bearer " + token.getToken();


⸻

Option C — Ask an admin to create the secret (classic)

If you must use client credentials + secret:
	1.	Admin (or someone with proper role) creates Client Secret in the App Registration.
	2.	They give you the Value (only shown once).
	3.	You store it (Key Vault/env var) and use ClientSecretCredential:

import com.azure.identity.ClientSecretCredential;
import com.azure.identity.ClientSecretCredentialBuilder;
import com.azure.core.credential.TokenRequestContext;

ClientSecretCredential cred = new ClientSecretCredentialBuilder()
    .tenantId("<TENANT_ID>")
    .clientId("<CLIENT_ID>")
    .clientSecret("<CLIENT_SECRET>")
    .build();

var token = cred.getToken(new TokenRequestContext()
    .addScopes("https://graph.microsoft.com/.default"))
    .block();
String bearer = "Bearer " + token.getToken();

You still need admin consent for application permissions in Microsoft Graph (e.g., Files.ReadWrite.All, Sites.Read.All) if you’re doing app-only operations.

⸻

Which path should you pick?
	•	You don’t have Entra access now:
	•	For local dev: use Device Code Flow (Option A2) to test file uploads to your own OneDrive/SharePoint with delegated permissions.
	•	For production: ask an admin to set up Managed Identity (A1) or certificate auth (B). These keep credentials out of code.
	•	You must use Copilot Retrieval API (app-only):
Device Code Flow won’t cut it. You’ll need an admin to either:
	•	enable Managed Identity for your runtime (A1), or
	•	register a cert (B), or
	•	create a secret (C).
And grant application permissions + admin consent.

⸻

Quick fallback for your current project

If you’re blocked on secrets/certs but want to keep developing:
	1.	Switch your upload calls to delegated for now (Device Code Flow).
	2.	Skip Retrieval API temporarily (or swap to your own vector store like Azure AI Search during dev).
	3.	Keep the Azure OpenAI calls as-is (they use API key).

I can give you a drop-in Device Code token provider bean and a feature flag so your app can run in two modes:
	•	AUTH_MODE=delegated (no secret; dev only)
	•	AUTH_MODE=app (managed identity/cert/secret; prod)

Say the word and I’ll paste that code.
